// Code generated by sql2gql. DO NOT EDIT.

package table

import (
	"database/sql"

	sq "github.com/elgris/sqrl"
	"github.com/ketan-10/sql2gql/examples/pokemon/internal"
	"github.com/ketan-10/sql2gql/examples/pokemon/sql2gql/enum"
	"github.com/pkg/errors"
)

type PokemonEvolutionMatchup struct {
	ID                   int                                  `json:"id" db:"id"`
	PokemonID            int                                  `json:"pokemon_id" db:"pokemon_id"`
	EvolvesFromSpeciesID sql.NullInt64                        `json:"evolves_from_species_id" db:"evolves_from_species_id"`
	Habitat              *enum.PokemonEvolutionMatchupHabitat `json:"habitat" db:"habitat"`

	GenderRate    int          `json:"gender_rate" db:"gender_rate"`
	CaptureRate   int          `json:"capture_rate" db:"capture_rate"`
	BaseHappiness int          `json:"base_happiness" db:"base_happiness"`
	Active        bool         `json:"active" db:"active"`
	CreatedAt     sql.NullTime `json:"created_at" db:"created_at"`
	UpdatedAt     sql.NullTime `json:"updated_at" db:"updated_at"`
}

type PokemonEvolutionMatchupFilter struct {
	ID                   internal.FilterOnField
	PokemonID            internal.FilterOnField
	EvolvesFromSpeciesID internal.FilterOnField
	Habitat              internal.FilterOnField
	GenderRate           internal.FilterOnField
	CaptureRate          internal.FilterOnField
	BaseHappiness        internal.FilterOnField
	Active               internal.FilterOnField
	CreatedAt            internal.FilterOnField
	UpdatedAt            internal.FilterOnField
	Wheres               []sq.Sqlizer
	Joins                []sq.Sqlizer
	LeftJoins            []sq.Sqlizer
	GroupBys             []string
	Havings              []sq.Sqlizer
}

func (f *PokemonEvolutionMatchupFilter) NewFilter() interface{} {
	if f == nil {
		return &PokemonEvolutionMatchupFilter{}
	}
	return f
}

func (f *PokemonEvolutionMatchupFilter) TableName() string {
	return "`pokemon_evolution_matchup`"
}

func (f *PokemonEvolutionMatchupFilter) ModuleName() string {
	return "pokemon_evolution_matchup"
}

func (f *PokemonEvolutionMatchupFilter) IsNil() bool {
	return f == nil
}
func (f *PokemonEvolutionMatchupFilter) AddID(filterType internal.FilterType, v interface{}) {
	f.ID = append(f.ID, map[internal.FilterType]interface{}{filterType: v})
}
func (f *PokemonEvolutionMatchupFilter) AddPokemonID(filterType internal.FilterType, v interface{}) {
	f.PokemonID = append(f.PokemonID, map[internal.FilterType]interface{}{filterType: v})
}
func (f *PokemonEvolutionMatchupFilter) AddEvolvesFromSpeciesID(filterType internal.FilterType, v interface{}) {
	f.EvolvesFromSpeciesID = append(f.EvolvesFromSpeciesID, map[internal.FilterType]interface{}{filterType: v})
}
func (f *PokemonEvolutionMatchupFilter) AddHabitat(filterType internal.FilterType, v interface{}) {
	f.Habitat = append(f.Habitat, map[internal.FilterType]interface{}{filterType: v})
}
func (f *PokemonEvolutionMatchupFilter) AddGenderRate(filterType internal.FilterType, v interface{}) {
	f.GenderRate = append(f.GenderRate, map[internal.FilterType]interface{}{filterType: v})
}
func (f *PokemonEvolutionMatchupFilter) AddCaptureRate(filterType internal.FilterType, v interface{}) {
	f.CaptureRate = append(f.CaptureRate, map[internal.FilterType]interface{}{filterType: v})
}
func (f *PokemonEvolutionMatchupFilter) AddBaseHappiness(filterType internal.FilterType, v interface{}) {
	f.BaseHappiness = append(f.BaseHappiness, map[internal.FilterType]interface{}{filterType: v})
}
func (f *PokemonEvolutionMatchupFilter) AddActive(filterType internal.FilterType, v interface{}) {
	f.Active = append(f.Active, map[internal.FilterType]interface{}{filterType: v})
}
func (f *PokemonEvolutionMatchupFilter) AddCreatedAt(filterType internal.FilterType, v interface{}) {
	f.CreatedAt = append(f.CreatedAt, map[internal.FilterType]interface{}{filterType: v})
}
func (f *PokemonEvolutionMatchupFilter) AddUpdatedAt(filterType internal.FilterType, v interface{}) {
	f.UpdatedAt = append(f.UpdatedAt, map[internal.FilterType]interface{}{filterType: v})
}

func (f *PokemonEvolutionMatchupFilter) Where(v sq.Sqlizer) *PokemonEvolutionMatchupFilter {
	f.Wheres = append(f.Wheres, v)
	return f
}

func (f *PokemonEvolutionMatchupFilter) Join(j sq.Sqlizer) *PokemonEvolutionMatchupFilter {
	f.Joins = append(f.Joins, j)
	return f
}

func (f *PokemonEvolutionMatchupFilter) LeftJoin(j sq.Sqlizer) *PokemonEvolutionMatchupFilter {
	f.LeftJoins = append(f.LeftJoins, j)
	return f
}

func (f *PokemonEvolutionMatchupFilter) GroupBy(gb string) *PokemonEvolutionMatchupFilter {
	f.GroupBys = append(f.GroupBys, gb)
	return f
}

func (f *PokemonEvolutionMatchupFilter) Having(h sq.Sqlizer) *PokemonEvolutionMatchupFilter {
	f.Havings = append(f.Havings, h)
	return f
}

type PokemonEvolutionMatchupCreate struct {
	PokemonID            int                                  `json:"pokemon_id" db:"pokemon_id"`
	EvolvesFromSpeciesID sql.NullInt64                        `json:"evolves_from_species_id" db:"evolves_from_species_id"`
	Habitat              *enum.PokemonEvolutionMatchupHabitat `json:"habitat" db:"habitat"`
	GenderRate           int                                  `json:"gender_rate" db:"gender_rate"`
	CaptureRate          int                                  `json:"capture_rate" db:"capture_rate"`
	BaseHappiness        int                                  `json:"base_happiness" db:"base_happiness"`
}

// TODO: We have to exclude AutoGenerated fields
// For now I am keeping it in, as not sure how it affects
type PokemonEvolutionMatchupUpdate struct {
	PokemonID            *int                                 // pokemon_id
	EvolvesFromSpeciesID *sql.NullInt64                       // evolves_from_species_id
	Habitat              *enum.PokemonEvolutionMatchupHabitat // habitat
	GenderRate           *int                                 // gender_rate
	CaptureRate          *int                                 // capture_rate
	BaseHappiness        *int                                 // base_happiness
	Active               *bool                                // active
}

// helper functions
func (u *PokemonEvolutionMatchupUpdate) ToPokemonEvolutionMatchupCreate() (res PokemonEvolutionMatchupCreate, err error) {
	if u.PokemonID != nil {
		res.PokemonID = *u.PokemonID
	} else {
		return res, errors.New("Value Can not be NULL")
	}
	if u.EvolvesFromSpeciesID != nil {
		res.EvolvesFromSpeciesID = *u.EvolvesFromSpeciesID
	}
	if u.Habitat != nil {
		res.Habitat = u.Habitat
	}
	if u.GenderRate != nil {
		res.GenderRate = *u.GenderRate
	} else {
		return res, errors.New("Value Can not be NULL")
	}
	if u.CaptureRate != nil {
		res.CaptureRate = *u.CaptureRate
	} else {
		return res, errors.New("Value Can not be NULL")
	}
	if u.BaseHappiness != nil {
		res.BaseHappiness = *u.BaseHappiness
	} else {
		return res, errors.New("Value Can not be NULL")
	}
	return res, nil
}

type ListPokemonEvolutionMatchup struct {
	TotalCount int
	Data       []PokemonEvolutionMatchup
}

func (l *ListPokemonEvolutionMatchup) GetAllID() []int {
	var res []int
	for _, item := range l.Data {
		res = append(res, item.ID)
	}
	return res
}
func (l *ListPokemonEvolutionMatchup) GetAllPokemonID() []int {
	var res []int
	for _, item := range l.Data {
		res = append(res, item.PokemonID)
	}
	return res
}
func (l *ListPokemonEvolutionMatchup) GetAllEvolvesFromSpeciesID() []sql.NullInt64 {
	var res []sql.NullInt64
	for _, item := range l.Data {
		res = append(res, item.EvolvesFromSpeciesID)
	}
	return res
}
func (l *ListPokemonEvolutionMatchup) GetAllHabitat() []*enum.PokemonEvolutionMatchupHabitat {
	var res []*enum.PokemonEvolutionMatchupHabitat
	for _, item := range l.Data {
		res = append(res, item.Habitat)
	}
	return res
}
func (l *ListPokemonEvolutionMatchup) GetAllGenderRate() []int {
	var res []int
	for _, item := range l.Data {
		res = append(res, item.GenderRate)
	}
	return res
}
func (l *ListPokemonEvolutionMatchup) GetAllCaptureRate() []int {
	var res []int
	for _, item := range l.Data {
		res = append(res, item.CaptureRate)
	}
	return res
}
func (l *ListPokemonEvolutionMatchup) GetAllBaseHappiness() []int {
	var res []int
	for _, item := range l.Data {
		res = append(res, item.BaseHappiness)
	}
	return res
}
func (l *ListPokemonEvolutionMatchup) GetAllActive() []bool {
	var res []bool
	for _, item := range l.Data {
		res = append(res, item.Active)
	}
	return res
}
func (l *ListPokemonEvolutionMatchup) GetAllCreatedAt() []sql.NullTime {
	var res []sql.NullTime
	for _, item := range l.Data {
		res = append(res, item.CreatedAt)
	}
	return res
}
func (l *ListPokemonEvolutionMatchup) GetAllUpdatedAt() []sql.NullTime {
	var res []sql.NullTime
	for _, item := range l.Data {
		res = append(res, item.UpdatedAt)
	}
	return res
}

func (l *ListPokemonEvolutionMatchup) Filter(f func(item PokemonEvolutionMatchup) bool) (res ListPokemonEvolutionMatchup) {
	for _, item := range l.Data {
		if f(item) {
			res.Data = append(res.Data, item)
		}
	}
	res.TotalCount = len(res.Data)
	return res
}

func (l *ListPokemonEvolutionMatchup) Find(f func(item PokemonEvolutionMatchup) bool) (res PokemonEvolutionMatchup, found bool) {
	for _, item := range l.Data {
		if f(item) {
			return item, true
		}
	}
	return PokemonEvolutionMatchup{}, false
}

func (l *ListPokemonEvolutionMatchup) MapByPokemonID() (m map[int]ListPokemonEvolutionMatchup) {
	m = make(map[int]ListPokemonEvolutionMatchup)
	for _, item := range l.Data {
		list := m[item.PokemonID]
		list.Data = append(list.Data, item)

		m[item.PokemonID] = list
	}
	for k, v := range m {
		v.TotalCount = len(v.Data)
		m[k] = v
	}
	return m
}

func (l *ListPokemonEvolutionMatchup) MapByID() (m map[int]PokemonEvolutionMatchup) {
	m = make(map[int]PokemonEvolutionMatchup, len(l.Data))
	for _, item := range l.Data {
		m[item.ID] = item
	}
	return m
}
