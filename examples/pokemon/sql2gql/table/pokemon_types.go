// Code generated by sql2gql. DO NOT EDIT.

package table

import (
	"database/sql"

	sq "github.com/elgris/sqrl"
	"github.com/ketan-10/sql2gql/examples/pokemon/internal"
	"github.com/pkg/errors"
)

type PokemonTypes struct {
	ID        int          `json:"id" db:"id"`
	PokemonID int          `json:"pokemon_id" db:"pokemon_id"`
	TypeID    int          `json:"type_id" db:"type_id"`
	Slot      int          `json:"slot" db:"slot"`
	Active    bool         `json:"active" db:"active"`
	CreatedAt sql.NullTime `json:"created_at" db:"created_at"`
	UpdatedAt sql.NullTime `json:"updated_at" db:"updated_at"`
}

type PokemonTypesFilter struct {
	ID        internal.FilterOnField
	PokemonID internal.FilterOnField
	TypeID    internal.FilterOnField
	Slot      internal.FilterOnField
	Active    internal.FilterOnField
	CreatedAt internal.FilterOnField
	UpdatedAt internal.FilterOnField
	Wheres    []sq.Sqlizer
	Joins     []sq.Sqlizer
	LeftJoins []sq.Sqlizer
	GroupBys  []string
	Havings   []sq.Sqlizer
}

func (f *PokemonTypesFilter) NewFilter() interface{} {
	if f == nil {
		return &PokemonTypesFilter{}
	}
	return f
}

func (f *PokemonTypesFilter) TableName() string {
	return "`pokemon_types`"
}

func (f *PokemonTypesFilter) ModuleName() string {
	return "pokemon_types"
}

func (f *PokemonTypesFilter) IsNil() bool {
	return f == nil
}
func (f *PokemonTypesFilter) AddID(filterType internal.FilterType, v interface{}) {
	f.ID = append(f.ID, map[internal.FilterType]interface{}{filterType: v})
}
func (f *PokemonTypesFilter) AddPokemonID(filterType internal.FilterType, v interface{}) {
	f.PokemonID = append(f.PokemonID, map[internal.FilterType]interface{}{filterType: v})
}
func (f *PokemonTypesFilter) AddTypeID(filterType internal.FilterType, v interface{}) {
	f.TypeID = append(f.TypeID, map[internal.FilterType]interface{}{filterType: v})
}
func (f *PokemonTypesFilter) AddSlot(filterType internal.FilterType, v interface{}) {
	f.Slot = append(f.Slot, map[internal.FilterType]interface{}{filterType: v})
}
func (f *PokemonTypesFilter) AddActive(filterType internal.FilterType, v interface{}) {
	f.Active = append(f.Active, map[internal.FilterType]interface{}{filterType: v})
}
func (f *PokemonTypesFilter) AddCreatedAt(filterType internal.FilterType, v interface{}) {
	f.CreatedAt = append(f.CreatedAt, map[internal.FilterType]interface{}{filterType: v})
}
func (f *PokemonTypesFilter) AddUpdatedAt(filterType internal.FilterType, v interface{}) {
	f.UpdatedAt = append(f.UpdatedAt, map[internal.FilterType]interface{}{filterType: v})
}

func (f *PokemonTypesFilter) Where(v sq.Sqlizer) *PokemonTypesFilter {
	f.Wheres = append(f.Wheres, v)
	return f
}

func (f *PokemonTypesFilter) Join(j sq.Sqlizer) *PokemonTypesFilter {
	f.Joins = append(f.Joins, j)
	return f
}

func (f *PokemonTypesFilter) LeftJoin(j sq.Sqlizer) *PokemonTypesFilter {
	f.LeftJoins = append(f.LeftJoins, j)
	return f
}

func (f *PokemonTypesFilter) GroupBy(gb string) *PokemonTypesFilter {
	f.GroupBys = append(f.GroupBys, gb)
	return f
}

func (f *PokemonTypesFilter) Having(h sq.Sqlizer) *PokemonTypesFilter {
	f.Havings = append(f.Havings, h)
	return f
}

type PokemonTypesCreate struct {
	PokemonID int `json:"pokemon_id" db:"pokemon_id"`
	TypeID    int `json:"type_id" db:"type_id"`
	Slot      int `json:"slot" db:"slot"`
}

// TODO: We have to exclude AutoGenerated fields
// For now I am keeping it in, as not sure how it affects
type PokemonTypesUpdate struct {
	PokemonID *int  // pokemon_id
	TypeID    *int  // type_id
	Slot      *int  // slot
	Active    *bool // active
}

// helper functions
func (u *PokemonTypesUpdate) ToPokemonTypesCreate() (res PokemonTypesCreate, err error) {
	if u.PokemonID != nil {
		res.PokemonID = *u.PokemonID
	} else {
		return res, errors.New("Value Can not be NULL")
	}
	if u.TypeID != nil {
		res.TypeID = *u.TypeID
	} else {
		return res, errors.New("Value Can not be NULL")
	}
	if u.Slot != nil {
		res.Slot = *u.Slot
	} else {
		return res, errors.New("Value Can not be NULL")
	}
	return res, nil
}

type ListPokemonTypes struct {
	TotalCount int
	Data       []PokemonTypes
}

func (l *ListPokemonTypes) GetAllID() []int {
	var res []int
	for _, item := range l.Data {
		res = append(res, item.ID)
	}
	return res
}
func (l *ListPokemonTypes) GetAllPokemonID() []int {
	var res []int
	for _, item := range l.Data {
		res = append(res, item.PokemonID)
	}
	return res
}
func (l *ListPokemonTypes) GetAllTypeID() []int {
	var res []int
	for _, item := range l.Data {
		res = append(res, item.TypeID)
	}
	return res
}
func (l *ListPokemonTypes) GetAllSlot() []int {
	var res []int
	for _, item := range l.Data {
		res = append(res, item.Slot)
	}
	return res
}
func (l *ListPokemonTypes) GetAllActive() []bool {
	var res []bool
	for _, item := range l.Data {
		res = append(res, item.Active)
	}
	return res
}
func (l *ListPokemonTypes) GetAllCreatedAt() []sql.NullTime {
	var res []sql.NullTime
	for _, item := range l.Data {
		res = append(res, item.CreatedAt)
	}
	return res
}
func (l *ListPokemonTypes) GetAllUpdatedAt() []sql.NullTime {
	var res []sql.NullTime
	for _, item := range l.Data {
		res = append(res, item.UpdatedAt)
	}
	return res
}

func (l *ListPokemonTypes) Filter(f func(item PokemonTypes) bool) (res ListPokemonTypes) {
	for _, item := range l.Data {
		if f(item) {
			res.Data = append(res.Data, item)
		}
	}
	res.TotalCount = len(res.Data)
	return res
}

func (l *ListPokemonTypes) Find(f func(item PokemonTypes) bool) (res PokemonTypes, found bool) {
	for _, item := range l.Data {
		if f(item) {
			return item, true
		}
	}
	return PokemonTypes{}, false
}

func (l *ListPokemonTypes) MapByPokemonID() (m map[int]ListPokemonTypes) {
	m = make(map[int]ListPokemonTypes)
	for _, item := range l.Data {
		list := m[item.PokemonID]
		list.Data = append(list.Data, item)

		m[item.PokemonID] = list
	}
	for k, v := range m {
		v.TotalCount = len(v.Data)
		m[k] = v
	}
	return m
}

func (l *ListPokemonTypes) MapByID() (m map[int]PokemonTypes) {
	m = make(map[int]PokemonTypes, len(l.Data))
	for _, item := range l.Data {
		m[item.ID] = item
	}
	return m
}

func (l *ListPokemonTypes) MapByTypeID() (m map[int]ListPokemonTypes) {
	m = make(map[int]ListPokemonTypes)
	for _, item := range l.Data {
		list := m[item.TypeID]
		list.Data = append(list.Data, item)

		m[item.TypeID] = list
	}
	for k, v := range m {
		v.TotalCount = len(v.Data)
		m[k] = v
	}
	return m
}
