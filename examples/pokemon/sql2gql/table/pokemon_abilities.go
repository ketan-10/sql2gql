// Code generated by sql2gql. DO NOT EDIT.

package table

import (
	"database/sql"

	sq "github.com/elgris/sqrl"
	"github.com/ketan-10/sql2gql/examples/pokemon/internal"
	"github.com/pkg/errors"
)

type PokemonAbilities struct {
	ID        int          `json:"id" db:"id"`
	FkPokemon int          `json:"fk_pokemon" db:"fk_pokemon"`
	FkAbility int          `json:"fk_ability" db:"fk_ability"`
	IsHidden  bool         `json:"is_hidden" db:"is_hidden"`
	Slot      int          `json:"slot" db:"slot"`
	Active    bool         `json:"active" db:"active"`
	CreatedAt sql.NullTime `json:"created_at" db:"created_at"`
	UpdatedAt sql.NullTime `json:"updated_at" db:"updated_at"`
}

type PokemonAbilitiesFilter struct {
	ID        internal.FilterOnField
	FkPokemon internal.FilterOnField
	FkAbility internal.FilterOnField
	IsHidden  internal.FilterOnField
	Slot      internal.FilterOnField
	Active    internal.FilterOnField
	CreatedAt internal.FilterOnField
	UpdatedAt internal.FilterOnField
	Wheres    []sq.Sqlizer
	Joins     []sq.Sqlizer
	LeftJoins []sq.Sqlizer
	GroupBys  []string
	Havings   []sq.Sqlizer
}

func (f *PokemonAbilitiesFilter) NewFilter() interface{} {
	if f == nil {
		return &PokemonAbilitiesFilter{}
	}
	return f
}

func (f *PokemonAbilitiesFilter) TableName() string {
	return "`pokemon_abilities`"
}

func (f *PokemonAbilitiesFilter) ModuleName() string {
	return "pokemon_abilities"
}

func (f *PokemonAbilitiesFilter) IsNil() bool {
	return f == nil
}
func (f *PokemonAbilitiesFilter) AddID(filterType internal.FilterType, v interface{}) {
	f.ID = append(f.ID, map[internal.FilterType]interface{}{filterType: v})
}
func (f *PokemonAbilitiesFilter) AddFkPokemon(filterType internal.FilterType, v interface{}) {
	f.FkPokemon = append(f.FkPokemon, map[internal.FilterType]interface{}{filterType: v})
}
func (f *PokemonAbilitiesFilter) AddFkAbility(filterType internal.FilterType, v interface{}) {
	f.FkAbility = append(f.FkAbility, map[internal.FilterType]interface{}{filterType: v})
}
func (f *PokemonAbilitiesFilter) AddIsHidden(filterType internal.FilterType, v interface{}) {
	f.IsHidden = append(f.IsHidden, map[internal.FilterType]interface{}{filterType: v})
}
func (f *PokemonAbilitiesFilter) AddSlot(filterType internal.FilterType, v interface{}) {
	f.Slot = append(f.Slot, map[internal.FilterType]interface{}{filterType: v})
}
func (f *PokemonAbilitiesFilter) AddActive(filterType internal.FilterType, v interface{}) {
	f.Active = append(f.Active, map[internal.FilterType]interface{}{filterType: v})
}
func (f *PokemonAbilitiesFilter) AddCreatedAt(filterType internal.FilterType, v interface{}) {
	f.CreatedAt = append(f.CreatedAt, map[internal.FilterType]interface{}{filterType: v})
}
func (f *PokemonAbilitiesFilter) AddUpdatedAt(filterType internal.FilterType, v interface{}) {
	f.UpdatedAt = append(f.UpdatedAt, map[internal.FilterType]interface{}{filterType: v})
}

func (f *PokemonAbilitiesFilter) Where(v sq.Sqlizer) *PokemonAbilitiesFilter {
	f.Wheres = append(f.Wheres, v)
	return f
}

func (f *PokemonAbilitiesFilter) Join(j sq.Sqlizer) *PokemonAbilitiesFilter {
	f.Joins = append(f.Joins, j)
	return f
}

func (f *PokemonAbilitiesFilter) LeftJoin(j sq.Sqlizer) *PokemonAbilitiesFilter {
	f.LeftJoins = append(f.LeftJoins, j)
	return f
}

func (f *PokemonAbilitiesFilter) GroupBy(gb string) *PokemonAbilitiesFilter {
	f.GroupBys = append(f.GroupBys, gb)
	return f
}

func (f *PokemonAbilitiesFilter) Having(h sq.Sqlizer) *PokemonAbilitiesFilter {
	f.Havings = append(f.Havings, h)
	return f
}

type PokemonAbilitiesCreate struct {
	FkPokemon int  `json:"fk_pokemon" db:"fk_pokemon"`
	FkAbility int  `json:"fk_ability" db:"fk_ability"`
	IsHidden  bool `json:"is_hidden" db:"is_hidden"`
	Slot      int  `json:"slot" db:"slot"`
}

// TODO: We have to exclude AutoGenerated fields
// For now I am keeping it in, as not sure how it affects
type PokemonAbilitiesUpdate struct {
	FkPokemon *int  // fk_pokemon
	FkAbility *int  // fk_ability
	IsHidden  *bool // is_hidden
	Slot      *int  // slot
	Active    *bool // active
}

// helper functions
func (u *PokemonAbilitiesUpdate) ToPokemonAbilitiesCreate() (res PokemonAbilitiesCreate, err error) {
	if u.FkPokemon != nil {
		res.FkPokemon = *u.FkPokemon
	} else {
		return res, errors.New("Value Can not be NULL")
	}
	if u.FkAbility != nil {
		res.FkAbility = *u.FkAbility
	} else {
		return res, errors.New("Value Can not be NULL")
	}
	if u.IsHidden != nil {
		res.IsHidden = *u.IsHidden
	} else {
		return res, errors.New("Value Can not be NULL")
	}
	if u.Slot != nil {
		res.Slot = *u.Slot
	} else {
		return res, errors.New("Value Can not be NULL")
	}
	return res, nil
}

type ListPokemonAbilities struct {
	TotalCount int
	Data       []PokemonAbilities
}

func (l *ListPokemonAbilities) GetAllID() []int {
	var res []int
	for _, item := range l.Data {
		res = append(res, item.ID)
	}
	return res
}
func (l *ListPokemonAbilities) GetAllFkPokemon() []int {
	var res []int
	for _, item := range l.Data {
		res = append(res, item.FkPokemon)
	}
	return res
}
func (l *ListPokemonAbilities) GetAllFkAbility() []int {
	var res []int
	for _, item := range l.Data {
		res = append(res, item.FkAbility)
	}
	return res
}
func (l *ListPokemonAbilities) GetAllIsHidden() []bool {
	var res []bool
	for _, item := range l.Data {
		res = append(res, item.IsHidden)
	}
	return res
}
func (l *ListPokemonAbilities) GetAllSlot() []int {
	var res []int
	for _, item := range l.Data {
		res = append(res, item.Slot)
	}
	return res
}
func (l *ListPokemonAbilities) GetAllActive() []bool {
	var res []bool
	for _, item := range l.Data {
		res = append(res, item.Active)
	}
	return res
}
func (l *ListPokemonAbilities) GetAllCreatedAt() []sql.NullTime {
	var res []sql.NullTime
	for _, item := range l.Data {
		res = append(res, item.CreatedAt)
	}
	return res
}
func (l *ListPokemonAbilities) GetAllUpdatedAt() []sql.NullTime {
	var res []sql.NullTime
	for _, item := range l.Data {
		res = append(res, item.UpdatedAt)
	}
	return res
}

func (l *ListPokemonAbilities) Filter(f func(item PokemonAbilities) bool) (res ListPokemonAbilities) {
	for _, item := range l.Data {
		if f(item) {
			res.Data = append(res.Data, item)
		}
	}
	res.TotalCount = len(res.Data)
	return res
}

func (l *ListPokemonAbilities) Find(f func(item PokemonAbilities) bool) (res PokemonAbilities, found bool) {
	for _, item := range l.Data {
		if f(item) {
			return item, true
		}
	}
	return PokemonAbilities{}, false
}
func (l *ListPokemonAbilities) MapByID() (m map[int]PokemonAbilities) {
	m = make(map[int]PokemonAbilities, len(l.Data))
	for _, item := range l.Data {
		m[item.ID] = item
	}
	return m
}

func (l *ListPokemonAbilities) MapByFkAbility() (m map[int]ListPokemonAbilities) {
	m = make(map[int]ListPokemonAbilities)
	for _, item := range l.Data {
		list := m[item.FkAbility]
		list.Data = append(list.Data, item)

		m[item.FkAbility] = list
	}
	for k, v := range m {
		v.TotalCount = len(v.Data)
		m[k] = v
	}
	return m
}

func (l *ListPokemonAbilities) MapByFkPokemon() (m map[int]ListPokemonAbilities) {
	m = make(map[int]ListPokemonAbilities)
	for _, item := range l.Data {
		list := m[item.FkPokemon]
		list.Data = append(list.Data, item)

		m[item.FkPokemon] = list
	}
	for k, v := range m {
		v.TotalCount = len(v.Data)
		m[k] = v
	}
	return m
}
