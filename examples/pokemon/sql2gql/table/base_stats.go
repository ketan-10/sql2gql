// Code generated by sql2gql. DO NOT EDIT.

package table

import (
	"database/sql"

	sq "github.com/elgris/sqrl"
	"github.com/ketan-10/sql2gql/examples/pokemon/internal"
	"github.com/pkg/errors"
)

type BaseStats struct {
	ID        int           `json:"id" db:"id"`
	FkPokemon int           `json:"fk_pokemon" db:"fk_pokemon"`
	BHp       sql.NullInt64 `json:"b_hp" db:"b_hp"`
	BAtk      sql.NullInt64 `json:"b_atk" db:"b_atk"`
	BDef      sql.NullInt64 `json:"b_def" db:"b_def"`
	BSpAtk    sql.NullInt64 `json:"b_sp_atk" db:"b_sp_atk"`
	BSpDef    sql.NullInt64 `json:"b_sp_def" db:"b_sp_def"`
	BSpeed    sql.NullInt64 `json:"b_speed" db:"b_speed"`
	Active    bool          `json:"active" db:"active"`
	CreatedAt sql.NullTime  `json:"created_at" db:"created_at"`
	UpdatedAt sql.NullTime  `json:"updated_at" db:"updated_at"`
}

type BaseStatsFilter struct {
	ID        internal.FilterOnField
	FkPokemon internal.FilterOnField
	BHp       internal.FilterOnField
	BAtk      internal.FilterOnField
	BDef      internal.FilterOnField
	BSpAtk    internal.FilterOnField
	BSpDef    internal.FilterOnField
	BSpeed    internal.FilterOnField
	Active    internal.FilterOnField
	CreatedAt internal.FilterOnField
	UpdatedAt internal.FilterOnField
	Wheres    []sq.Sqlizer
	Joins     []sq.Sqlizer
	LeftJoins []sq.Sqlizer
	GroupBys  []string
	Havings   []sq.Sqlizer
}

func (f *BaseStatsFilter) NewFilter() interface{} {
	if f == nil {
		return &BaseStatsFilter{}
	}
	return f
}

func (f *BaseStatsFilter) TableName() string {
	return "`base_stats`"
}

func (f *BaseStatsFilter) ModuleName() string {
	return "base_stats"
}

func (f *BaseStatsFilter) IsNil() bool {
	return f == nil
}
func (f *BaseStatsFilter) AddID(filterType internal.FilterType, v interface{}) {
	f.ID = append(f.ID, map[internal.FilterType]interface{}{filterType: v})
}
func (f *BaseStatsFilter) AddFkPokemon(filterType internal.FilterType, v interface{}) {
	f.FkPokemon = append(f.FkPokemon, map[internal.FilterType]interface{}{filterType: v})
}
func (f *BaseStatsFilter) AddBHp(filterType internal.FilterType, v interface{}) {
	f.BHp = append(f.BHp, map[internal.FilterType]interface{}{filterType: v})
}
func (f *BaseStatsFilter) AddBAtk(filterType internal.FilterType, v interface{}) {
	f.BAtk = append(f.BAtk, map[internal.FilterType]interface{}{filterType: v})
}
func (f *BaseStatsFilter) AddBDef(filterType internal.FilterType, v interface{}) {
	f.BDef = append(f.BDef, map[internal.FilterType]interface{}{filterType: v})
}
func (f *BaseStatsFilter) AddBSpAtk(filterType internal.FilterType, v interface{}) {
	f.BSpAtk = append(f.BSpAtk, map[internal.FilterType]interface{}{filterType: v})
}
func (f *BaseStatsFilter) AddBSpDef(filterType internal.FilterType, v interface{}) {
	f.BSpDef = append(f.BSpDef, map[internal.FilterType]interface{}{filterType: v})
}
func (f *BaseStatsFilter) AddBSpeed(filterType internal.FilterType, v interface{}) {
	f.BSpeed = append(f.BSpeed, map[internal.FilterType]interface{}{filterType: v})
}
func (f *BaseStatsFilter) AddActive(filterType internal.FilterType, v interface{}) {
	f.Active = append(f.Active, map[internal.FilterType]interface{}{filterType: v})
}
func (f *BaseStatsFilter) AddCreatedAt(filterType internal.FilterType, v interface{}) {
	f.CreatedAt = append(f.CreatedAt, map[internal.FilterType]interface{}{filterType: v})
}
func (f *BaseStatsFilter) AddUpdatedAt(filterType internal.FilterType, v interface{}) {
	f.UpdatedAt = append(f.UpdatedAt, map[internal.FilterType]interface{}{filterType: v})
}

func (f *BaseStatsFilter) Where(v sq.Sqlizer) *BaseStatsFilter {
	f.Wheres = append(f.Wheres, v)
	return f
}

func (f *BaseStatsFilter) Join(j sq.Sqlizer) *BaseStatsFilter {
	f.Joins = append(f.Joins, j)
	return f
}

func (f *BaseStatsFilter) LeftJoin(j sq.Sqlizer) *BaseStatsFilter {
	f.LeftJoins = append(f.LeftJoins, j)
	return f
}

func (f *BaseStatsFilter) GroupBy(gb string) *BaseStatsFilter {
	f.GroupBys = append(f.GroupBys, gb)
	return f
}

func (f *BaseStatsFilter) Having(h sq.Sqlizer) *BaseStatsFilter {
	f.Havings = append(f.Havings, h)
	return f
}

type BaseStatsCreate struct {
	FkPokemon int           `json:"fk_pokemon" db:"fk_pokemon"`
	BHp       sql.NullInt64 `json:"b_hp" db:"b_hp"`
	BAtk      sql.NullInt64 `json:"b_atk" db:"b_atk"`
	BDef      sql.NullInt64 `json:"b_def" db:"b_def"`
	BSpAtk    sql.NullInt64 `json:"b_sp_atk" db:"b_sp_atk"`
	BSpDef    sql.NullInt64 `json:"b_sp_def" db:"b_sp_def"`
	BSpeed    sql.NullInt64 `json:"b_speed" db:"b_speed"`
}

// TODO: We have to exclude AutoGenerated fields
// For now I am keeping it in, as not sure how it affects
type BaseStatsUpdate struct {
	FkPokemon *int           // fk_pokemon
	BHp       *sql.NullInt64 // b_hp
	BAtk      *sql.NullInt64 // b_atk
	BDef      *sql.NullInt64 // b_def
	BSpAtk    *sql.NullInt64 // b_sp_atk
	BSpDef    *sql.NullInt64 // b_sp_def
	BSpeed    *sql.NullInt64 // b_speed
	Active    *bool          // active
}

// helper functions
func (u *BaseStatsUpdate) ToBaseStatsCreate() (res BaseStatsCreate, err error) {
	if u.FkPokemon != nil {
		res.FkPokemon = *u.FkPokemon
	} else {
		return res, errors.New("Value Can not be NULL")
	}
	if u.BHp != nil {
		res.BHp = *u.BHp
	}
	if u.BAtk != nil {
		res.BAtk = *u.BAtk
	}
	if u.BDef != nil {
		res.BDef = *u.BDef
	}
	if u.BSpAtk != nil {
		res.BSpAtk = *u.BSpAtk
	}
	if u.BSpDef != nil {
		res.BSpDef = *u.BSpDef
	}
	if u.BSpeed != nil {
		res.BSpeed = *u.BSpeed
	}
	return res, nil
}

type ListBaseStats struct {
	TotalCount int
	Data       []BaseStats
}

func (l *ListBaseStats) GetAllID() []int {
	var res []int
	for _, item := range l.Data {
		res = append(res, item.ID)
	}
	return res
}
func (l *ListBaseStats) GetAllFkPokemon() []int {
	var res []int
	for _, item := range l.Data {
		res = append(res, item.FkPokemon)
	}
	return res
}
func (l *ListBaseStats) GetAllBHp() []sql.NullInt64 {
	var res []sql.NullInt64
	for _, item := range l.Data {
		res = append(res, item.BHp)
	}
	return res
}
func (l *ListBaseStats) GetAllBAtk() []sql.NullInt64 {
	var res []sql.NullInt64
	for _, item := range l.Data {
		res = append(res, item.BAtk)
	}
	return res
}
func (l *ListBaseStats) GetAllBDef() []sql.NullInt64 {
	var res []sql.NullInt64
	for _, item := range l.Data {
		res = append(res, item.BDef)
	}
	return res
}
func (l *ListBaseStats) GetAllBSpAtk() []sql.NullInt64 {
	var res []sql.NullInt64
	for _, item := range l.Data {
		res = append(res, item.BSpAtk)
	}
	return res
}
func (l *ListBaseStats) GetAllBSpDef() []sql.NullInt64 {
	var res []sql.NullInt64
	for _, item := range l.Data {
		res = append(res, item.BSpDef)
	}
	return res
}
func (l *ListBaseStats) GetAllBSpeed() []sql.NullInt64 {
	var res []sql.NullInt64
	for _, item := range l.Data {
		res = append(res, item.BSpeed)
	}
	return res
}
func (l *ListBaseStats) GetAllActive() []bool {
	var res []bool
	for _, item := range l.Data {
		res = append(res, item.Active)
	}
	return res
}
func (l *ListBaseStats) GetAllCreatedAt() []sql.NullTime {
	var res []sql.NullTime
	for _, item := range l.Data {
		res = append(res, item.CreatedAt)
	}
	return res
}
func (l *ListBaseStats) GetAllUpdatedAt() []sql.NullTime {
	var res []sql.NullTime
	for _, item := range l.Data {
		res = append(res, item.UpdatedAt)
	}
	return res
}

func (l *ListBaseStats) Filter(f func(item BaseStats) bool) (res ListBaseStats) {
	for _, item := range l.Data {
		if f(item) {
			res.Data = append(res.Data, item)
		}
	}
	res.TotalCount = len(res.Data)
	return res
}

func (l *ListBaseStats) Find(f func(item BaseStats) bool) (res BaseStats, found bool) {
	for _, item := range l.Data {
		if f(item) {
			return item, true
		}
	}
	return BaseStats{}, false
}
func (l *ListBaseStats) MapByID() (m map[int]BaseStats) {
	m = make(map[int]BaseStats, len(l.Data))
	for _, item := range l.Data {
		m[item.ID] = item
	}
	return m
}

func (l *ListBaseStats) MapByFkPokemon() (m map[int]ListBaseStats) {
	m = make(map[int]ListBaseStats)
	for _, item := range l.Data {
		list := m[item.FkPokemon]
		list.Data = append(list.Data, item)

		m[item.FkPokemon] = list
	}
	for k, v := range m {
		v.TotalCount = len(v.Data)
		m[k] = v
	}
	return m
}
